syntax = "proto3";
package io.axoniq.axonserver.grpc.internal;
import "common.proto";
import "command.proto";
import "query.proto";
import "control.proto";
import "event.proto";
import "raft.proto";
option java_multiple_files = true;

service MessagingClusterService {
    // Creates a stream between 2 nodes in the cluster
    // calling side is service provider to called side
    rpc OpenStream (stream ConnectorCommand) returns (stream ConnectorResponse) {
    }

    rpc GetContextLeader (ContextName) returns (NodeInfo) {

    }

    rpc GetCluster (EmptyRequest) returns (stream NodeInfo) {
    }
}

/**
 * Service that contains specific operations to retrieve information from a lower tier in a multi tier context
 */
service LowerTierEventStoreService {
    /* creates a flow controlled stream for events from the lower tier */
    rpc ListEvents (stream GetTransactionsRequest) returns (stream TransactionWithToken) {
    }

    /* creates a flow controlled stream for snapshots from the lower tier */
    rpc ListSnapshots (stream GetTransactionsRequest) returns (stream TransactionWithToken) {
    }

    /* finds the highest sequence number for an aggregate from the lower tier */
    rpc GetHighestSequenceNumber (GetHighestSequenceNumberRequest) returns (GetHighestSequenceNumberResponse) {
    }

    // Retrieves the last committed token in event store. Returns -1 when no events in store.
    rpc GetLastSnapshotToken (GetLastSnapshotTokenRequest) returns (io.axoniq.axonserver.grpc.event.TrackingToken) {
    }


}

/**
 * Services on config leader
 */
service RaftConfigService {
    rpc InitCluster (ContextNames) returns (InstructionAck) {
    }

    rpc JoinCluster (NodeInfo) returns (UpdateLicense) {
    }

    rpc DeleteNode (NodeName) returns (InstructionAck) {
    }

    rpc CreateReplicationGroup (ReplicationGroup) returns (InstructionAck) {
    }

    rpc AddNodeToReplicationGroup (NodeReplicationGroup) returns (InstructionAck) {
    }

    rpc DeleteNodeFromReplicationGroup (NodeReplicationGroup) returns (InstructionAck) {
    }

    rpc DeleteReplicationGroup (DeleteReplicationGroupRequest) returns (InstructionAck) {
    }

    rpc CreateContext (ReplicationGroupContext) returns (InstructionAck) {
    }

    rpc DeleteContext (DeleteContextRequest) returns (InstructionAck) {
    }

    rpc UpdateApplication (Application) returns (Application) {
    }

    rpc DeleteApplication (Application) returns (InstructionAck) {
    }

    rpc RefreshToken (Application) returns (Application) {
    }

    rpc UpdateUser (User) returns (InstructionAck) {
    }

    rpc DeleteUser (User) returns (InstructionAck) {
    }

    rpc UpdateProcessorLBStrategy (ProcessorLBStrategy) returns (InstructionAck) {
    }

    rpc DeleteProcessorLBStrategy (ProcessorLBStrategy) returns (InstructionAck) {
    }

}

/**
 * Services on context leader/member callled from config leader
 */
service RaftGroupService {

    rpc InitReplicationGroup (ReplicationGroup) returns (ReplicationGroupConfiguration) {
    }

    rpc DeleteReplicationGroup (DeleteReplicationGroupRequest) returns (InstructionAck) {
    }

    rpc AddServer (ReplicationGroup) returns (ReplicationGroupUpdateConfirmation) {
    }

    rpc RemoveServer (ReplicationGroup) returns (ReplicationGroupUpdateConfirmation) {
    }

    rpc GetStatus (ReplicationGroup) returns (stream ReplicationGroup) {
    }

    rpc AppendEntry (ReplicationGroupEntry) returns (InstructionAck) {
    }

    rpc Configuration (ReplicationGroupName) returns (ReplicationGroupConfiguration) {
    }

    rpc TransferLeadership (ReplicationGroupName) returns (InstructionAck) {
    }

    // Notify a node that a node will be deleted from a context.
    rpc PreDeleteNodeFromReplicationGroup (NodeReplicationGroup) returns (InstructionAck) {
    }
}

message EmptyRequest {

}

message NodeReplicationGroup {
    string node_name = 1;
    string replication_group_name = 2;
    io.axoniq.axonserver.grpc.cluster.Role role = 3;
}

message ConnectorCommand {
    oneof request {
        ConnectRequest connect = 1;
        InternalCommandSubscription subscribe_command = 2;
        InternalCommandSubscription unsubscribe_command = 3;
        ForwardedCommandResponse command_response = 4;
        InternalQuerySubscription subscribe_query = 5;
        InternalQuerySubscription unsubscribe_query = 6;
        ForwardedQueryResponse query_response = 7;
        InternalFlowControl flow_control = 8;
        DeleteNode delete_node = 9;
        NodeMetrics metrics = 11;
        QueryComplete query_complete = 12;
        ClientStatus client_status = 14;
        ClientEventProcessorStatus client_event_processor_status = 15;
        ClientEventProcessor start_client_event_processor = 16;
        ClientEventProcessor pause_client_event_processor = 17;
        io.axoniq.axonserver.grpc.query.SubscriptionQueryResponse subscription_query_response = 26;
        ClientEventProcessorSegment release_segment = 32;
        ClientEventProcessor request_processor_status = 35;
        CommandHandlerStatus command_handler_status = 36;
        QueryHandlerStatus query_handler_status = 37;
        ClientEventProcessorSegment split_segment = 38;
        ClientEventProcessorSegment merge_segment = 39;

        /*Axon Server internal event, propagated to all nodes in the cluster*/
        io.axoniq.axonserver.grpc.SerializedObject internal_event = 40;
        UpdateLicense update_license = 41;
    }
}

/*
    A representation of a QueryResponse that is (to be) forwarded between AxonServer nodes. It passes additional
    information which is not directly provided by the responding application components itself.

    Developer note:
    all fields defined in QueryResponse must be represented here with the same ID, name and type. Any field IDs used
    in this message in addition to QueryResponse should be marked as reserved in QueryResponse, to avoid clashes.
*/
message ForwardedQueryResponse {

    /* The unique identifier of this message */
    string message_identifier = 1;

    /* The error code, if an error occurred while processing */
    string error_code = 2;

    /* A more detailed description of the error, if one occurred */
    ErrorMessage error_message = 3;

    /* The payload of the response message */
    SerializedObject payload = 4;

    /* Any meta data elements provided in the Query Response message */
    map<string, MetaDataValue> meta_data = 5;

    /* Instructions for AxonServer when routing this message */
    repeated ProcessingInstruction processing_instructions = 6;

    /* The identifier of the Query to which this is a response */
    string request_identifier = 7;

    /*
        The ClientID of the component that provided the response. For compatibility with nodes using the legacy (< 4.1) API,
        check for ProcessingInstruction with key 5 for a Client ID if this field contains no information
    */
    string respondingClientId = 15;
}

message ForwardedCommandResponse {
    string request_identifier = 1;
    bytes response = 2;
}

message DeleteNode {
    string node_name = 1;
    int64 generation = 2;
}

message UpdateLicense {
    bytes license = 1;
}

message ClientStatus {
    string client_name = 1;
    string component_name = 2;
    string context = 3;
    bool connected = 4;
    map<string, string> tags = 5;
}

message CommandHandlerStatus {
    string context = 1;
    string client_name = 2;
    bool connected = 3;
}

message QueryHandlerStatus {
    string context = 1;
    string client_name = 2;
    bool connected = 3;
}

message DBInstanceStatus {
    string hub_node = 1;
    string context = 2;
    io.axoniq.axonserver.grpc.control.NodeInfo db_instance = 3;
    bool connected = 4;
}

message InternalCommandSubscription {
    io.axoniq.axonserver.grpc.command.CommandSubscription command = 1;
    string context = 2;
}

message InternalQuerySubscription {
    io.axoniq.axonserver.grpc.query.QuerySubscription query = 1;
    string context = 2;
}

message ConnectRequest {
    NodeInfo nodeInfo = 1;
    bool admin = 2;
}

message ConnectorResponse {
    oneof response {
        InstructionAck confirmation = 1;
        ForwardedCommand command = 2;
        ConnectResponse connect_response = 3;
        ForwardedQuery query = 4;
        ClientSubscriptionQueryRequest subscription_query_request = 26;
    }
}

message ForwardedQuery {
    string client = 1;
    string context = 2;
    bytes query = 3;
}

message ForwardedCommand {
    string client = 1;
    string context = 2;
    string message_id = 3;
    bytes command = 4;
}

message ClientSubscriptionQueryRequest {
    string client = 1;
    string context = 2;
    io.axoniq.axonserver.grpc.query.SubscriptionQueryRequest subscription_query_request = 3;
}

message ConnectResponse {
    bool deleted = 6;
}

message ModelVersion {
    string name = 1;
    int64 value = 2;
}

message ContextRole {
    string name = 1;
    string node_label = 4;
    io.axoniq.axonserver.grpc.cluster.Role role = 5;
}

message QueryComplete {
    string message_id = 1;
    string client = 2;
}

message NodeInfo {
    string node_name = 1;
    string host_name = 2;
    string internal_host_name = 3;
    int32 grpc_port = 4;
    int32 grpc_internal_port = 5;
    int32 http_port = 6;
    int64 active_since = 7;
    int32 version = 8;
    repeated ContextRole contexts = 9;
    map<string, string> tags = 10;
}

message InternalFlowControl {
    string node_name = 1;
    Group group = 2;
    int64 permits = 3;
}

enum Group {
    COMMAND = 0;
    QUERY = 1;
}

message GetHighestSequenceNumberRequest {
    string context = 1;
    string aggregate_identifier = 2;
    /* contains the maximum number of segments to check (for checking new aggregates) */
    int32 max_segments_hint = 3;
    /* contains the maximum token to check, events above this token have already been checked by the primary node */
    int64 max_token_hint = 4;
}

message GetHighestSequenceNumberResponse {
    int64 sequence_number = 1;
}

message GetTransactionsRequest {
    string context = 1;

    /* The token to start streaming from */
    int64 tracking_token = 2;

    /* The token to stop streaming (exclusive), 0 means no limit */
    int64 to_tracking_token = 3;

    /* The number of messages the server may send before it needs to wait for more permits */
    int64 number_of_permits = 4;
}

message ReplicationGroupEntry {
    string replication_group_name = 1;
    string entry_name = 2;
    bytes entry = 3;
}

message ProcessorsLBStrategy {
    int64 version = 1;
    repeated ProcessorLBStrategy processor = 2;
}

message Metrics {
    int32 request_count = 1;
    int64 interval = 2;
}

message ClientEventProcessorStatus {
    string client = 1;
    io.axoniq.axonserver.grpc.control.EventProcessorInfo event_processor_info = 2;
    string context = 3;
}

message ClientEventProcessor {
    string client = 1;
    string processor_name = 2;
    string context = 3;
}

message ClientEventProcessorSegment {
    string client = 1;
    string processor_name = 2;
    string context = 3;
    int32 segment_identifier = 4;
}

message NodeMetrics {
    string node = 1;
    repeated Metric metrics = 2;
}

message Metric {
    string name = 1;
    int64 count = 2;
    double median = 3;
    double percentile95 = 5;
    double percentile99 = 7;
    double mean = 11;
    map<string, string> tags = 13;
    double value = 14;
    double max = 15;
    double min = 16;
    reserved 4, 6, 8, 9, 10, 12;
}

message Permits {
    int64 permits = 1;
}

message TransactionWithToken {
    int64 token = 1;
    int32 version = 2;
    repeated bytes events = 3;
    string context = 4;
}

/*
* Sent to members of config cluster to update context
*/
message ReplicationGroup {
    string name = 1;
    repeated ReplicationGroupMember members = 2;
}

message ReplicationGroupContext {
    string replication_group_name = 1;
    string context_name = 2;
    map<string, string> meta_data = 3;
}


message ReplicationGroupUpdateConfirmation {
    bool success = 1;
    string message = 2;
    repeated ReplicationGroupMember members = 3;
    bool pending = 4;
}

message ReplicationGroupMember {
    string node_id = 1;
    string host = 2;
    int32 port = 3;
    State state = 4;
    string node_name = 5;
    io.axoniq.axonserver.grpc.cluster.Role role = 6;
}

message Application {
    string name = 1;
    string description = 2;
    string token_prefix = 3;
    string token = 4;
    repeated ApplicationContextRole roles_per_context = 5;
    map<string, string> meta_data = 6;
}

message ApplicationContextRole {
    string context = 1;
    repeated string roles = 2;
}

message Applications {
    repeated Application applications = 1;
}

message User {
    string name = 1;
    string password = 2;
    repeated UserContextRole roles = 3;
}

message UserContextRole {
    string context = 1;
    string role = 2;
}

message Users {
    repeated User users = 1;
}

message ContextNames {
    repeated string contexts = 1;
}

enum State {
    VOTING = 0;
    LEADER = 1;
    NON_VOTING = 2;
    INITIALIZING = 3;
}

message ClusterConfiguration {
    repeated ReplicationGroupConfiguration replication_groups = 1;
    repeated ReplicationGroupContext contexts = 2;
}

message ContextConfiguration {
    string context = 1;
    repeated NodeInfoWithLabel nodes = 2;
    bool pending = 3;
    map<string, string> meta_data = 4;
}

message ReplicationGroupConfiguration {
    string replication_group_name = 1;
    repeated NodeInfoWithLabel nodes = 2;
    bool pending = 3;
}

message NodeInfoWithLabel {
    NodeInfo node = 1;
    string label = 2;
    io.axoniq.axonserver.grpc.cluster.Role role = 3;
}

message ContextName {
    string context = 1;
}
message ReplicationGroupName {
    string name = 1;
}

message DeleteContextRequest {
    string context = 1;
    bool preserve_eventstore = 2;
    string replication_group_name = 3;
}

message DeleteReplicationGroupRequest {
    string replication_group_name = 1;
    bool preserve_eventstore = 2;
}

message NodeName {
    string node = 1;
    bool require_empty = 2;
}

message ProcessorLBStrategy {
    //    string component = 1; this field is obsoleted, the line is commented in order not to use this index for other purposes
    string processor = 2;
    string context = 3;
    string strategy = 4;
    string token_store_identifier = 5;
}

message ContextApplication {
    string context = 1;
    string name = 2;
    string token_prefix = 3;
    string hashed_token = 4;
    repeated string roles = 5;
}

message ContextUser {
    string context = 1;
    User user = 2;
}

message ContextProcessorLBStrategy {
    string context = 1;
    ProcessorLBStrategy processorLBStrategy = 2;
}

message MetaData {
    map<string, MetaDataValue> meta_data = 1;
}

message ReplicationGroupContexts {
    string replication_group_name = 1;
    repeated Context context = 2;

}
message Context {
    string context_name = 1;
    map<string, string> meta_data = 2;
    int64 firstEventToken = 3;
    int64 firstSnapshotToken = 4;
}

message GetLastSnapshotTokenRequest {
    string context = 1;
}