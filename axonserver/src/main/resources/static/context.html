<!--
  ~  Copyright (c) 2017-2023 AxonIQ B.V. and/or licensed to AxonIQ B.V.
  ~  under one or more contributor license agreements.
  ~
  ~  Licensed under the AxonIQ Open Source License Agreement v1.0;
  ~  you may not use this file except in compliance with the license.
  ~
  -->
<script>
    //# sourceURL=context.js
    globals.pageView = new Vue({
        el: '#context',
        data: {
            contexts: [],
            showAdd: true,
            showUpdate: false,
            replicationGroups: [],
            contextProperties: [],
            updatableContextProperties: [],
            availableTiers: [],
            availableEventStorages: new Map(),
            availableSnapshotStorages: new Map(),
            chosenEventTiers: {
                primary: [],
                secondary: [],
                passive_backup: [],
                active_backup: []
            },
            chosenSnapshotTiers: {
                primary: [],
                secondary: [],
                passive_backup: [],
                active_backup: []
            },
            selectedTierNodeRole: 'primary',
            newContext: {
                nodes: [],
                selectedReplicationGroup: "",
                replicationGroup: null,
                metaData: {},
                metaDataLabel: '',
                metaDataValue: ''
            },
            currentContext: null,
            admin: globals.admin,
            webSocketInfo: globals.webSocketInfo,
            nodes: [],
            removeNodeData: {},
            deleteContextData: {},
            roles: []
        }, mounted() {
            this.loadContexts();
            axios.get("v1/replicationgroups/roles").then(response => {
                this.roles = response.data;
            });
            axios.get("v1/public").then(response => {
                this.nodes = response.data;
                this.initNewContext();
            });
            axios.get("v1/public/replicationgroups").then(response => {
                for (let i = 0; i < response.data.length; i++) {
                    let name = response.data[i].name;
                    if (name.charAt(0) !== '_') {
                        this.replicationGroups.push(response.data[i]);
                    }
                }
                this.initNewContext();
            });
            axios.get("v1/public/context-properties").then(response => {
                this.contextProperties = response.data;
                this.updatableContextProperties = this.contextProperties.filter(p => p.updatable);
            });
            axios.get("v1/public/tier").then(response => {
                this.availableTiers = response.data;
                Object.keys(this.chosenEventTiers).forEach(nodeRole => {
                    if (this.chosenEventTiers[nodeRole].length === 0)
                        this.chosenEventTiers[nodeRole].push(structuredClone(this.availableTiers[0]));
                    if (this.chosenSnapshotTiers[nodeRole].length === 0)
                        this.chosenSnapshotTiers[nodeRole].push(structuredClone(this.availableTiers[0]));
                })
            });
            axios.get("v1/public/storages?type=event").then(response => {
                this.availableEventStorages = new Map(Object.entries(response.data));
            });
            axios.get("v1/public/storages?type=snapshot").then(response => {
                this.availableSnapshotStorages = new Map(Object.entries(response.data));
            });
            this.connect();
        }, beforeDestroy() {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        }, methods: {
            isEnterprise() {
                return globals.isEnterprise()
            },
            isDisabled() {
                if (!globals.isEnterprise() && this.contexts.length > 1) {
                    return true;
                }
            },
            initNewContext() {
                this.newContext.metaData = {};
                this.newContext.metaDataKey = "";
                this.newContext.metaDataValue = "";
                this.newContext.context = "";
                this.newContext.replicationGroup = "";
                this.newContext.selectedReplicationGroup = "";
                for (let a = 0; a < this.nodes.length; a++) {
                    this.newContext.nodes[a] = {
                        name: this.nodes[a].name,
                        selectedRole: "none"
                    };
                }

                this.resetMultiTierConf();

                this.$forceUpdate();
            },
            resetMultiTierConf() {
                Object.keys(this.chosenEventTiers).forEach(nodeRole => {
                    this.chosenEventTiers[nodeRole] = [];
                    this.chosenSnapshotTiers[nodeRole] = [];
                });


                if (this.availableTiers[0] !== undefined) {
                    Object.keys(this.chosenEventTiers).forEach(nodeRole => {
                        this.chosenEventTiers[nodeRole].push(structuredClone(this.availableTiers[0]));
                        this.chosenSnapshotTiers[nodeRole].push(structuredClone(this.availableTiers[0]));
                    });
                }
            },
            loadContexts() {
                axios.get("v1/public/context").then(response => {
                    this.contexts = response.data;
                });
            },
            checkAndCreateContext() {
                if (this.isMultiTierConfigured()) {
                    this.$modal.show('create-mt-context');
                } else {
                    this.createContext();
                }
            },
            createContext() {
                this.hideModal('create-mt-context');
                if (!this.newContext.context) {
                    alert("No Context Name set");
                    return;
                }
                if (this.existsContext()) {
                    alert("Context " + this.newContext.context + " already exists");
                    return;
                }

                let group = this.newContext.selectedReplicationGroup ? this.newContext.selectedReplicationGroup : this.newContext.replicationGroup;
                let context = {
                    context: this.newContext.context,
                    replicationGroup: group,
                    roles: [],
                    metaData: this.newContext.metaData
                };
                let primaryNode = false;
                for (var i = 0; i < this.newContext.nodes.length; i++) {
                    if (this.newContext.nodes[i].selectedRole !== "none") {
                        context.roles.push({
                            "node": this.newContext.nodes[i].name,
                            "role": this.newContext.nodes[i].selectedRole,
                        });
                        if (this.newContext.nodes[i].selectedRole === "PRIMARY") {
                            primaryNode = true;
                        }
                    }
                }

                if (!this.newContext.selectedReplicationGroup && !primaryNode) {
                    alert("Select at least one node as primary node");
                    return;
                }

                if (this.newContext.metaDataLabel && this.newContext.metaDataValue) {
                    this.addMetaData()
                }

                this.collectTierInfo(this.newContext);

                axios.post("v1/context", context).then(response => {
                    this.initNewContext();
                    this.loadContexts();
                });
            },
            doUpdateContext() {
                this.hideModal('update-mt-context');
                if (this.currentContext.metaDataLabel && this.currentContext.metaDataValue) {
                    this.addMetaDataToCurrent()
                }

                this.collectTierInfo(this.currentContext);

                axios.patch("v1/context/" + this.currentContext.context,
                    this.currentContext.metaData).then(response => {
                    this.showAdd = true;
                    this.showUpdate = false;
                    this.currentContext = null;
                    this.selectedTierNodeRole = "primary";
                    this.resetMultiTierConf();
                    this.loadContexts();
                });
            },
            existsContext() {
                for (var i = 0; i < this.contexts.length; i++) {
                    if (this.contexts[i].context === this.newContext.context) {
                        return true;
                    }
                }
                return false;
            },
            deleteContext(context) {
                if (this.isInternalContext(context)) {
                    alert("Cannot delete internal context")
                } else {
                    this.deleteContextData = {
                        "context": context.context,
                        "retypeContext": "",
                        "preserveData": false
                    };
                    this.$modal.show('delete-context');
                }
            },
            doDeleteContext() {
                if (this.deleteContextData.context === this.deleteContextData.retypeContext) {
                    axios.delete("v1/context/" + this.deleteContextData.context + "?preserveEventStore="
                        + this.deleteContextData.preserveData).then(
                        () => {
                            this.loadContexts();
                            this.hideModal('delete-context');
                        }
                    )
                } else {
                    alert('Invalid context name');
                }
            },
            hideModal(name) {
                this.$modal.hide(name);
            },
            connect() {
                let me = this;
                me.webSocketInfo.subscribe('/topic/cluster', () => {
                    me.loadContexts();
                }, (sub) => {
                    me.subscription = sub;
                });
            },
            isInternalContext(context) {
                return context.context.charAt(0) === '_';
            },
            createReplicationGroup(newContext) {
                return !newContext.selectedReplicationGroup;
            },
            deleteMetaData(key) {
                delete this.newContext.metaData[key];
                this.$forceUpdate();
            },
            isReadonly(metaDataKey) {
                let prop = this.contextProperties.find(v => v.key === metaDataKey);
                return prop ? !prop.updatable : false;
            },
            checkAndUpdateContext() {
                if (this.isMultiTierConfigured()) {
                    this.$modal.show('update-mt-context');
                } else {
                    this.doUpdateContext();
                }
            },
            updateContext(context) {
                this.showUpdate = true;
                this.showAdd = false;
                this.currentContext = {
                    "context": context.context,
                    "metaData": Object.assign({}, context.metaData),
                    "metaDataLabel": '',
                    "selectedReplicationGroup": context.replicationGroup,
                    "metaDataValue": ''
                };
                this.selectedTierNodeRole = "primary";

                Object.keys(this.chosenEventTiers).forEach(nodeRole => {
                    this.chosenEventTiers[nodeRole] = this.storages('event', this.currentContext, nodeRole);
                })

                Object.keys(this.chosenSnapshotTiers).forEach(nodeRole => {
                    this.chosenSnapshotTiers[nodeRole] = this.storages('snapshot', this.currentContext, nodeRole);
                })

            },
            cancelUpdate() {
                this.currentContext = null;
                this.showUpdate = false;
                this.showAdd = true;
                this.selectedTierNodeRole = "primary";
                this.resetMultiTierConf();
            },
            addMetaDataToCurrent() {
                if (!this.currentContext.metaDataLabel || !this.currentContext.metaDataValue) {
                    alert("specify name and value")
                    return;
                }
                this.currentContext.metaData[this.currentContext.metaDataLabel] = this.currentContext.metaDataValue;
                this.currentContext.metaDataValue = '';
                console.log(JSON.stringify(this.currentContext.metaData))

                // setting the property value for the field with the suggestion box does not work, so set the new
                // value on the suggestion box object
                this.$refs.currentContextProperty.setText('');
            },
            deleteMetaDataFromCurrent(key) {
                delete this.currentContext.metaData[key];
                this.$forceUpdate();
            },
            addMetaData() {
                if (!this.newContext.metaDataLabel || !this.newContext.metaDataValue) {
                    alert("specify name and value")
                    return;
                }

                this.newContext.metaData[this.newContext.metaDataLabel] = this.newContext.metaDataValue;
                this.newContext.metaDataValue = '';
                // setting the property value for the field with the suggestion box does not work, so set the new
                // value on the suggestion box object
                this.$refs.newContextProperty.setText('');
            },
            addEventTier() {
                let currentLevel = this.chosenEventTiers[this.selectedTierNodeRole].length;
                this.chosenEventTiers[this.selectedTierNodeRole].push(structuredClone(this.showAvailableTiers(currentLevel)[0]));
            },
            addSnapshotTier() {
                let currentLevel = this.chosenSnapshotTiers[this.selectedTierNodeRole].length;
                this.chosenSnapshotTiers[this.selectedTierNodeRole].push(structuredClone(this.showAvailableTiers(currentLevel)[0]));
            },
            onTierSelect(e, tier, index, storage) {
                let selectedTier = e.target.options[e.target.options.selectedIndex]._value;
                let store = (storage === 'event') ? this.chosenEventTiers[this.selectedTierNodeRole] : this.chosenSnapshotTiers[this.selectedTierNodeRole];
                store[index] = {...selectedTier};
                this.$forceUpdate();
                if (selectedTier.id === 'black_hole') {
                    this.$modal.show('black_hole');
                }
            },
            showTierStorage(index, storage) {
                let store = (storage === 'event') ? this.chosenEventTiers[this.selectedTierNodeRole] : this.chosenSnapshotTiers[this.selectedTierNodeRole];
                return store[index].id === 'custom_storage';
            },
            showAfterSelect(tierLevel) {
                return tierLevel > 0;
            },
            showAvailableTiers(index, storage) {
                let store = (storage === 'event') ? this.chosenEventTiers[this.selectedTierNodeRole] : this.chosenSnapshotTiers[this.selectedTierNodeRole];

                return this.availableTiers
                    .filter(t => t.level === -1 || t.level <= (store.length - 1))
                    .filter(t => !(index > 0 && t.id === 'default'))
            },
            showAddTier(index, storageType) {
                try {
                    let store = (storageType === 'event') ? this.chosenEventTiers[this.selectedTierNodeRole] : this.chosenSnapshotTiers[this.selectedTierNodeRole];
                    return store[index].id !== 'black_hole';
                } catch (e) {
                    return true;
                }
            },
            collectTierInfo(context) {
                let metaData = context.metaData;
                Object.keys(this.chosenEventTiers).forEach(nodeRole => {
                    let store = this.chosenEventTiers[nodeRole];
                    let storageType = 'event';
                    if (this.tabNodeState(nodeRole) !== 'tier-tab-disabled') {
                        this.collectTierInfoToMetaData(store, storageType, nodeRole, metaData);
                    }
                })

                Object.keys(this.chosenSnapshotTiers).forEach(nodeRole => {
                    let store = this.chosenSnapshotTiers[nodeRole];
                    let storageType = 'snapshot';
                    if (this.tabNodeState(nodeRole) !== 'tier-tab-disabled') {
                        this.collectTierInfoToMetaData(store, storageType, nodeRole, metaData);
                    }
                })

            },
            collectTierInfoToMetaData(store, storageType, nodeRole, metaData) {
                let lTier = 'tier';
                let lStorage = 'storage';
                let lRetentionTime = 'retention-time';
                let lRetentionSize = 'retention-size';

                store
                    .forEach((tier, index) => {
                        let prefix = storageType.concat('.');
                        let suffixLevel = '';
                        if (index > 0) {
                            suffixLevel = '.' + index;
                        }
                        let suffixNodeRole = '.' + nodeRole;

                        let retentionTime = 0;
                        let retentionSize = 0;

                        switch (tier.retentionType) {
                            case 'minutes':
                                retentionTime = 'PT' + tier.retentionAmount + 'M';
                                break;
                            case 'hours':
                                retentionTime = 'PT' + tier.retentionAmount + 'H';
                                break;
                            case 'days':
                                retentionTime = 'P' + tier.retentionAmount + 'D';
                                break;
                            case 'MB':
                                retentionSize = tier.retentionAmount * 1048576;
                                break;
                            case 'GB':
                                retentionSize = tier.retentionAmount * 1073741824;
                                break;
                            default:
                                if (index > 0) {
                                    alert("You must define valid retention time or size for " + storageType + " tier at level " + index + "!");
                                    throw "You must define valid retention time or size for" + storageType + " tier at level " + index + "!";
                                }
                        }

                        metaData[prefix.concat(lTier.concat(suffixLevel).concat(suffixNodeRole))] = tier.id;

                        if (tier.id === "default") {
                            metaData[prefix.concat(lStorage.concat(suffixLevel).concat(suffixNodeRole))] = 'primary';
                        }

                        if (tier.id === "custom_storage" && tier.storage === undefined) {
                            alert("You must define valid storage storage for " + storageType + " tier at level " + index + "!");
                            throw 'You must define valid storage storage for ' + storageType + ' tier at level ' + index + '!';
                        }

                        if (tier.id === "custom_storage" && tier.storage.length >= 1) {
                            metaData[prefix.concat(lStorage.concat(suffixLevel).concat(suffixNodeRole))] = tier.storage;
                        }

                        if (retentionTime < 0 ) {
                            alert("You must define valid retention time for " + storageType + " tier at level " + index + "!");
                            throw "You must define valid retention time for " + storageType + " tier at level " + index + "!";
                        }

                        if (retentionSize < 0 ) {
                            alert("You must define valid retention size for " + storageType + " tier at level " + index + "!");
                            throw "You must define valid retention size for " + storageType + " tier at level " + index + "!";
                        }

                        if (retentionTime !== 0) {
                            metaData[prefix.concat(lRetentionTime.concat(suffixLevel).concat(suffixNodeRole))] = retentionTime;
                            delete metaData[prefix.concat(lRetentionSize.concat(suffixLevel).concat(suffixNodeRole))];
                        }
                        if (retentionSize !== 0) {
                            metaData[prefix.concat(lRetentionSize.concat(suffixLevel).concat(suffixNodeRole))] = retentionSize;
                            delete metaData[prefix.concat(lRetentionTime.concat(suffixLevel).concat(suffixNodeRole))];
                        }
                    });
            },
            isEphemeral(context) {
                return Object.keys(context.metaData).some(key => key.startsWith("event.tier") && context.metaData[key] === 'black_hole');
            },
            isMultiTierConfigured() {
                for (let nodeRole of Object.keys(this.chosenEventTiers)) {
                    let store = this.chosenEventTiers[nodeRole];
                    if (store.length > 1) {
                        return true;
                    }
                }

                for (let nodeRole of Object.keys(this.chosenSnapshotTiers)) {
                    let store = this.chosenSnapshotTiers[nodeRole];
                    if (store.length > 1) {
                        return true;
                    }
                }

                return false;
            },
            isMultiTier(context) {
                let eventTiers = Object.keys(context.metaData).filter(key => key.startsWith("event.tier")).length;
                let snapshotTiers = Object.keys(context.metaData).filter(key => key.startsWith("snapshot.tier")).length;
                return (eventTiers > 1) || (snapshotTiers > 1);
            },
            showAvailableStorages(index, storageType) {
                let store = (storageType === 'event') ? this.chosenEventTiers[this.selectedTierNodeRole] : this.chosenSnapshotTiers[this.selectedTierNodeRole];
                let availableStores = (storageType === 'event') ? this.availableEventStorages : this.availableSnapshotStorages;
                let chosen = store.slice(0, index).map(tier => {
                    if (tier.id === 'default') {
                        tier.storage = 'primary';
                    }
                    return tier;
                }).map(tier => tier.storage);
                return Array.from(availableStores).filter(([storage, unused]) => !chosen.includes(storage));
            },
            isTierMetaData(key) {
                let lTier = 'tier';
                let lStorage = 'storage';
                let lRetentionTime = 'retention-time';
                let lRetentionSize = 'retention-size';

                if (key === "event.retention-time" || key === "snapshot.retention-time") {
                    return false;
                }

                return key.includes(lTier) ||
                    key.includes(lStorage) ||
                    key.includes(lRetentionTime) ||
                    key.includes(lRetentionSize);
            },
            tabNodeState(nodeRoleName) {
                if (nodeRoleName === this.selectedTierNodeRole) return 'tier-tab-active';
                else {
                    let availableNodeRoles1 = [];
                    let availableNodeRoles2 = [];

                    if (this.newContext) {
                        availableNodeRoles1 = this.newContext.nodes.map(n => n.selectedRole).filter(r => r !== 'none');
                    }

                    if (this.replicationGroups) {
                        if (this.currentContext) {
                            let selectedRP = this.replicationGroups.find(rp => rp.name
                                === this.currentContext.selectedReplicationGroup);
                            if (selectedRP) {
                                availableNodeRoles2 = selectedRP.roles.map(r => r.role);
                            }
                        } else {
                            let selectedRP = this.replicationGroups.find(rp => rp.name
                                === this.newContext.selectedReplicationGroup);
                            if (selectedRP) {
                                availableNodeRoles2 = selectedRP.roles.map(r => r.role);
                            }
                        }
                    }

                    let availableNodeRoles = availableNodeRoles1.concat(availableNodeRoles2)

                    if (availableNodeRoles.some(role => role === nodeRoleName.toUpperCase())) {
                        return 'tier-tab-available';
                    } else {
                        return 'tier-tab-disabled';
                    }
                }
            },
            changeSelectedTierNodeRole(nodeRoleName) {
                if (this.tabNodeState(nodeRoleName) === 'tier-tab-disabled') {
                    return;
                } else {
                    this.selectedTierNodeRole = nodeRoleName;
                    this.$forceUpdate();
                }
            },
            updateUI() {
                this.$forceUpdate();
            },
            replicationGroupUpdated() {
                this.selectedTierNodeRole = "primary";
                for (let a = 0; a < this.newContext.nodes.length; a++) {
                    this.newContext.nodes[a].selectedRole = "none"
                }
                this.newContext.nodes = [];
                this.updateUI();
            },
            storages(storageType, context, selectedTierNodeRole) {
                if (context.context === '_admin') {
                    return [];
                }

                let lTier = storageType.concat('.tier');
                let lStorage = storageType.concat('.storage');
                let lRetentionTime = storageType.concat('.retention-time');
                let lRetentionSize = storageType.concat('.retention-size');

                let contextMeta = context.metaData;

                let storageArray = [];
                let i = 0;
                do {
                    let suffix = (i === 0) ? '.'.concat(selectedTierNodeRole) : '.' + i + '.'.concat(selectedTierNodeRole);

                    let tier = contextMeta[lTier.concat(suffix)];
                    let storage = contextMeta[lStorage.concat(suffix)];
                    let retentionTime = contextMeta[lRetentionTime.concat(suffix)];
                    let retentionSize = contextMeta[lRetentionSize.concat(suffix)];

                    if (i === 0 && tier === undefined) {
                        tier = 'default';
                        storage = 'primary';
                    }

                    let retentionFormatted;

                    if (retentionSize) {
                        retentionFormatted = this.humanFileSize(retentionSize);
                    } else if (retentionTime) {
                        retentionFormatted = retentionTime
                            .replace('P', '')
                            .replace('T', '')
                            .replace('H', ' hr')
                            .replace('M', ' min')
                            .replace('D', ' d');
                    }

                    if (tier || storage || retentionTime || retentionSize) {
                        if (tier === 'black_hole') storage = 'remove';

                        let retentionAmount = 0;
                        let retentionType = '';

                        if (retentionTime) {
                            if (retentionTime.includes('D')) {
                                retentionType = 'days';
                            } else if (retentionTime.includes('M')) {
                                retentionType = 'minutes';
                            } else {
                                retentionType = 'hours';
                            }
                            retentionAmount = retentionTime.replace(/[^0-9]/g, "");
                        } else if (retentionSize) {
                            retentionType = retentionFormatted.includes('GB') ? 'GB' : 'MB';
                            retentionAmount = retentionFormatted.replace(/[^0-9]/g, "");
                        }

                        storageArray.push({
                            id: tier,
                            name: tier,
                            tier: tier,
                            storage: storage,
                            retentionTime: retentionTime,
                            retentionSize: retentionSize,
                            retentionFormatted: retentionFormatted,
                            retentionAmount: retentionAmount,
                            retentionType: retentionType,
                            readOnly: true
                        });
                    } else {
                        break;
                    }
                    i = i + 1;
                } while (true);

                return storageArray;
            },
            humanFileSize(size) {
                let i = size == 0 ? 0 : Math.floor(Math.log(size) / Math.log(1024));
                return (size / Math.pow(1024, i)).toFixed(2) * 1 + ' ' + ['B', 'kB', 'MB', 'GB', 'TB'][i];
            }
        }
    });

</script>
<span id="context">
   <section id="applicationsOverview">
      <paginated-table :rows="contexts" name="contexts">
         <template #header>
            <th class="contextNameColumn">Context Name</th>
            <th class="contextNameColumn">Replication Group Name</th>
            <th class="contextMetaDataColumn">Context Options</th>
            <th class="storageColumn">Event storage</th>
            <th class="storageColumn">Snapshot storage</th>
         </template>
         <template #row="context">
             <td>{{ context.context }}
                <div class="label-holder">
                    <span v-if="isEphemeral(context)" class="ephemeral"
                          data-tooltip="Ephemeral context stores events for a limited amount of time, after which they are permanently deleted."><span
                            class="ephemeral-text ">ephemeral</span></span>
                    <span v-if="isMultiTier(context) && !isEphemeral(context)" class="multi-tier"
                          data-tooltip="This context splits event store into multiple locations (tiers).">multi-tier</span>
                </div>
               <span v-if="admin && !isInternalContext(context)" title="Delete Context"
                     @click="deleteContext(context)">
               <i class="far fa-trash-alt"></i>
               </span>
               <span v-if="admin && !isInternalContext(context)" v-disable="!isEnterprise()" title="Update Context"
                     @click="updateContext(context)">
               <i class="fas fa-pencil-alt"></i>
               </span>
            </td>
            <td>
               {{ context.replicationGroup }}
            </td>
            <td>
               <div v-for="key in Object.keys(context.metaData)" v-if="!isTierMetaData(key)">
                  <span class="metakey">{{ key }}</span>
                  <span class="metavalue">{{ context.metaData[key] }}</span>
               </div>
            </td>
             <td>
                 <template v-for="storage in storages('event',context, 'primary')">
                    <div v-if="storage.retentionFormatted" class="retentionBox">&#9716; {{
                            storage.retentionFormatted
                        }}</div>
                    <div class="bottom-arrow">&#8964;</div>
                    <div v-if="storage.id !== 'black_hole'" class="storageBox">{{ storage.storage }}</div>
                    <div v-if="storage.id === 'black_hole'" class="storageBlackHoleBox">{{ storage.storage }}</div>
                    <div class="bottom-arrow">&#8964;</div>
                 </template>
             </td>
             <td>
                 <template v-for="storage in storages('snapshot',context, 'primary')">
                    <div v-if="storage.retentionFormatted" class="retentionBox">&#9716; {{
                            storage.retentionFormatted
                        }}</div>
                    <div class="bottom-arrow">&#8964;</div>
                    <div v-if="storage.id !== 'black_hole'" class="storageBox">{{ storage.storage }}</div>
                    <div v-if="storage.id === 'black_hole'" class="storageBlackHoleBox">{{ storage.storage }}</div>
                    <div class="bottom-arrow">&#8964;</div>
                 </template>
             </td>
         </template>
      </paginated-table>
   </section>
   <div v-if="!hasFeature('MULTI_CONTEXT')  && isDisabled()" class="msg white">
      Multi-context and multi-tiered storage features are only available on Enterprise Edition. <a
           href="https://www.axoniq.io/products/axon-server" target="_blank" class="info">Learn more or request your trial license.<i
           class="fas fa-info-circle"></i></a>
   </div>
   <section v-if="admin && showAdd" id="newContextPanel">
      <div class="column configuration" v-disable="isDisabled()">
         <form id="contextForm">
            <ul>
               <li>
                  <span class="narrow">Context Name</span>
                  <span><input v-model="newContext.context" autocomplete="none" class="nodeRoleName"
                               data-lpignore="true"/></span>
               </li>
               <li>
                  <span class="narrow">Replication Group</span>
                  <span>
                     <select v-model="newContext.selectedReplicationGroup" class="nodeRoleName"
                             @change="replicationGroupUpdated()">
                        <option value="" v-if="isEnterprise()" v-disable="!isEnterprise()">-- create new --</option>
                        <option v-for="n in replicationGroups" :value="n.name">{{ n.name }}</option>
                     </select>
                  </span>
               </li>
               <li v-if="createReplicationGroup(newContext) && isEnterprise()">
                  <span class="narrow"></span>
                  <span style="display: inline-block; border: 1px solid #CCC">
                     <ul>
                        <li>
                           <span class="narrow">New Replication Group Name</span>
                           <span><input v-model="newContext.replicationGroup" autocomplete="none" class="nodeRoleName"
                                        data-lpignore="true"/></span>
                        </li>
                        <li>
                           <span class="narrow">Nodes</span>
                           <span>
                              <table class="nestedTable">
                                 <tr v-for="node in newContext.nodes">
                                    <td style="width: 60%">{{ node.name }}</td>
                                    <td>
                                       <select v-model="node.selectedRole" class="nodeRoleName" @change="updateUI()">
                                          <option value="none">-- none --</option>
                                          <option v-for="n in roles" :value="n">{{ n }}</option>
                                       </select>
                                    </td>
                                 </tr>
                              </table>
                           </span>
                        </li>
                     </ul>
                  </span>
               </li>
               <li></li>
               <li v-disable="!isEnterprise()">
                  <span class="narrow">Context Properties</span>
                  <span>
                     <table class="nestedTable">
                        <tbody>
                           <tr v-for="key in Object.keys(newContext.metaData)" v-if="!isTierMetaData(key)">
                              <td style="width: 60%">{{ key }}</td>
                              <td><input v-model="newContext.metaData[key]" class="propertyValue"
                                         data-lpignore="true"></td>
                              <td style="width: 20px">
                                 <span title="Delete Context Property" @click="deleteMetaData(key)">
                                 <i class="far fa-trash-alt"></i>
                                 </span>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                     <span style="width: 60%">
                        <component-suggestion-box ref="newContextProperty"
                                                  :options="contextProperties"
                                                  :value="newContext.metaDataLabel"
                                                  @input="newContext.metaDataLabel = $event">
                        </component-suggestion-box>
                     </span>
                     <span style="width: 30%;padding:5px;">
                     <input v-model="newContext.metaDataValue" class="propertyValue"
                            data-lpignore="true">
                     </span>
                     <span style="width: 15px" title="Add Context Property" @click="addMetaData()">
                     <i class="fas fa-plus"></i>
                     </span>
                  </span>
               </li>
                <li v-disable="!isEnterprise()">
                <span class="narrow" style="visibility: hidden">Node roles</span>
                <span class="tier-tabs-holder">
                        <span @click="changeSelectedTierNodeRole('primary')" class="tier-tab"
                              :class="tabNodeState('primary')">Primary</span>
                        <span @click="changeSelectedTierNodeRole('secondary')" class="tier-tab"
                              :class="tabNodeState('secondary')">Secondary</span>
                        <span @click="changeSelectedTierNodeRole('passive_backup')" class="tier-tab"
                              :class="tabNodeState('passive_backup')">Passive backup</span>
                        <span @click="changeSelectedTierNodeRole('active_backup')" class="tier-tab"
                              :class="tabNodeState('active_backup')">Active backup</span>
                </span>
                </li>
               <li v-disable="!isEnterprise()">
                  <span class="narrow" style="cursor: pointer" @click="$modal.show('about-multitier')">Event storage  <i
                          class="fas fa-question-circle"></i> </span>
                  <span class="tier-holder">
                     <table class="nestedTable">
                        <tr v-for="(tier, index) in chosenEventTiers[selectedTierNodeRole]" :value="tier">
                           <td>
                              <select class="tierName" :content="chosenEventTiers[selectedTierNodeRole][index].name"
                                      @change="onTierSelect($event,tier,index,'event')">
                                 <option v-for="n in showAvailableTiers(index,'event')" :value="n"
                                         :selected="n.id === chosenEventTiers[selectedTierNodeRole][index].id">{{
                                         n.name
                                     }}</option>
                              </select>
                           </td>
                           <td>
                              <select v-model="chosenEventTiers[selectedTierNodeRole][index].storage"
                                      v-if="showTierStorage(index,'event')" class="tierName">
                                  <option :value="undefined" disabled hidden selected>Select storage</option>
                                  <option v-for="[storage, path] in showAvailableStorages(index,'event')"
                                          :value="storage">{{ storage }}</option>
                              </select>
                              <em v-if="showTierStorage(index,'event')"
                                  @click="$modal.show('multitier-add-storage')"><i class="fas fa-info-circle"
                                                                                   style="margin-left: 5px; margin-top: 6px"></i></em>
                           </td>
                           <td>
                              <input v-model="chosenEventTiers[selectedTierNodeRole][index].retentionAmount"
                                     v-if="showAfterSelect(index)" class="tierName" data-lpignore="true"
                                     placeholder="after">
                           </td>
                           <td>
                              <select v-model="chosenEventTiers[selectedTierNodeRole][index].retentionType"
                                      v-if="showAfterSelect(index)" class="tierName">
                                 <option :value="undefined" disabled hidden selected>Select retention strategy</option>
                                 <option value="minutes">MINUTES (time based)</option>
                                 <option value="hours">HOURS (time based)</option>
                                 <option value="days">DAYS (time based)</option>
                                 <option value="MB">MEGABYTES (size based)</option>
                                 <option value="GB">GIGABYTES (size based)</option>
                              </select>
                           </td>
                           <td style="width: 15px"><span v-if="showAddTier(index,'event')" class="add-tier"
                                                         style="display: none; width: 15px; float: right !important;"
                                                         title="Add Tier" @click="addEventTier()"><i
                                   class="fas fa-plus"></i></span></td>
                        </tr>
                     </table>
                  </span>
               </li>
               <li v-disable="!isEnterprise()">
                  <span class="narrow" style="cursor: pointer" @click="$modal.show('about-multitier')">Snapshot storage <i
                          class="fas fa-question-circle"></i></span>
                  <span class="tier-holder">
                     <table class="nestedTable">
                        <tr v-for="(tier, index) in chosenSnapshotTiers[selectedTierNodeRole]" :value="tier">
                           <td>
                              <select class="tierName" :content="chosenSnapshotTiers[selectedTierNodeRole][index].name"
                                      @change="onTierSelect($event,tier,index,'snapshot')">
                                 <option v-for="n in showAvailableTiers(index,'snapshot')" :value="n"
                                         :selected="n.id === chosenSnapshotTiers[selectedTierNodeRole][index].id">{{
                                         n.name
                                     }}</option>
                              </select>
                           </td>
                           <td>
                              <select v-model="chosenSnapshotTiers[selectedTierNodeRole][index].storage"
                                      v-if="showTierStorage(index,'snapshot')" class="tierName">
                                  <option :value="undefined" disabled hidden selected>Select storage</option>
                                  <option v-for="[storage, path] in showAvailableStorages(index,'snapshot')"
                                          :value="storage">{{ storage }}</option>
                              </select>
                              <em  v-if="showTierStorage(index,'snapshot')"
                                   @click="$modal.show('multitier-add-storage')"><i class="fas fa-info-circle"
                                                                                   style="margin-left: 5px; margin-top: 6px"></i></em>
                           </td>
                           <td>
                              <input v-model="chosenSnapshotTiers[selectedTierNodeRole][index].retentionAmount"
                                     v-if="showAfterSelect(index)" class="tierName" data-lpignore="true"
                                     placeholder="after">
                           </td>
                           <td>
                              <select v-model="chosenSnapshotTiers[selectedTierNodeRole][index].retentionType"
                                      v-if="showAfterSelect(index)" class="tierName">
                                 <option :value="undefined" disabled hidden selected>Select retention strategy</option>
                                 <option value="minutes">MINUTES (time based)</option>
                                 <option value="hours">HOURS (time based)</option>
                                 <option value="days">DAYS (time based)</option>
                                 <option value="MB">MEGABYTES (size based)</option>
                                 <option value="GB">GIGABYTES (size based)</option>
                              </select>
                           </td>
                           <td style="width: 15px"><span v-if="showAddTier(index,'snapshot')" class="add-tier"
                                                         style="display: none; width: 15px; float: right !important;"
                                                         title="Add Tier" @click="addSnapshotTier()"><i
                                   class="fas fa-plus"></i></span></td>
                        </tr>
                     </table>
                  </span>
               </li>
               <li>
                  <span class="narrow">&nbsp;</span>
                  <span><button v-disable="isDisabled()" class="button"
                                @click.prevent="checkAndCreateContext()">Save</button></span>
               </li>
            </ul>
         </form>
      </div>
   </section>
   <section v-if="admin && showUpdate" id="updateContextPanel">
      <div class="column configuration">
         <form id="updateContext">
            <ul>
               <li>
                  <span class="narrow">Context Name</span>
                  <span>{{ currentContext.context }}</span>
               </li>
               <li>
                  <span class="narrow">Context Properties</span>
                  <span>
                     <table class="nestedTable">
                        <tbody>
                           <tr v-for="key in Object.keys(currentContext.metaData)" v-if="!isTierMetaData(key)">
                              <td style="width: 60%">{{ key }}</td>
                              <td>
                                 <span v-if="isReadonly(key)">
                                 {{ currentContext.metaData[key] }}
                                 </span>
                                 <input v-if=!isReadonly(key) v-model="currentContext.metaData[key]"
                                        class="propertyValue"
                                        data-lpignore="true"
                                 >
                              </td>
                              <td style="width: 20px">
                                 <span v-if=!isReadonly(key) title="Delete Context Property"
                                       @click="deleteMetaDataFromCurrent(key)">
                                 <i class="far fa-trash-alt"></i>
                                 </span>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                     <span style="width: 60%">
                        <component-suggestion-box ref="currentContextProperty"
                                                  :options="updatableContextProperties"
                                                  :value="currentContext.metaDataLabel"
                                                  @input="currentContext.metaDataLabel = $event">
                        </component-suggestion-box>
                     </span>
                     <span style="width: 30%;padding:5px;">
                     <input v-model="currentContext.metaDataValue" class="propertyValue"
                            data-lpignore="true">
                     </span>
                     <span style="width: 15px" title="Add Context Property"
                           @click="addMetaDataToCurrent()">
                     <i class="fas fa-plus"></i>
                     </span>
                  </span>
               </li>
               <li v-disable="!isEnterprise()">
                <span class="narrow" style="visibility: hidden">Node roles</span>
                <span class="tier-tabs-holder">
                        <span @click="changeSelectedTierNodeRole('primary')" class="tier-tab"
                              :class="tabNodeState('primary')">Primary</span>
                        <span @click="changeSelectedTierNodeRole('secondary')" class="tier-tab"
                              :class="tabNodeState('secondary')">Secondary</span>
                        <span @click="changeSelectedTierNodeRole('passive_backup')" class="tier-tab"
                              :class="tabNodeState('passive_backup')">Passive backup</span>
                        <span @click="changeSelectedTierNodeRole('active_backup')" class="tier-tab"
                              :class="tabNodeState('active_backup')">Active backup</span>
                </span>
                </li>
                <li v-disable="!isEnterprise()">
                  <span class="narrow">Event storage</span>
                  <span class="tier-holder">
                     <table class="nestedTable">
                        <tr v-for="(tier, index) in chosenEventTiers[selectedTierNodeRole]" :value="tier">
                           <td>
                              <select class="tierName" :content="chosenEventTiers[selectedTierNodeRole][index].name"
                                      :disabled="chosenEventTiers[selectedTierNodeRole][index].readOnly"
                                      @change="onTierSelect($event,tier,index,'event')">
                                 <option v-for="n in showAvailableTiers(index,'event')" :value="n"
                                         :selected="n.id === chosenEventTiers[selectedTierNodeRole][index].id">{{
                                         n.name
                                     }}</option>
                              </select>
                           </td>
                           <td>
                              <select v-model="chosenEventTiers[selectedTierNodeRole][index].storage"
                                      :disabled="chosenEventTiers[selectedTierNodeRole][index].readOnly"
                                      v-if="showTierStorage(index,'event')" class="tierName">
                                  <option :value="undefined" disabled hidden selected>Select storage</option>
                                  <option v-for="[storage, path] in showAvailableStorages(index,'event')"
                                          :value="storage">{{ storage }}</option>
                              </select>
                           </td>
                           <td>
                              <input v-model="chosenEventTiers[selectedTierNodeRole][index].retentionAmount"
                                     v-if="showAfterSelect(index)" class="tierName" data-lpignore="true"
                                     placeholder="after">
                           </td>
                           <td>
                              <select v-model="chosenEventTiers[selectedTierNodeRole][index].retentionType"
                                      v-if="showAfterSelect(index)" class="tierName">
                                 <option :value="undefined" disabled hidden selected>Select retention strategy</option>
                                 <option value="minutes">MINUTES (time based)</option>
                                 <option value="hours">HOURS (time based)</option>
                                 <option value="days">DAYS (time based)</option>
                                 <option value="MB">MEGABYTES (size based)</option>
                                 <option value="GB">GIGABYTES (size based)</option>
                              </select>
                           </td>
                           <td style="width: 15px"><span v-if="showAddTier(index,'event')" class="add-tier"
                                                         style="display: none; width: 15px; float: right !important;"
                                                         title="Add Tier" @click="addEventTier()"><i
                                   class="fas fa-plus"></i></span></td>
                        </tr>
                     </table>
                  </span>
               </li>
               <li v-disable="!isEnterprise()">
                  <span class="narrow">Snapshot storage</span>
                  <span class="tier-holder">
                     <table class="nestedTable">
                        <tr v-for="(tier, index) in chosenSnapshotTiers[selectedTierNodeRole]" :value="tier">
                           <td>
                                <select class="tierName"
                                        :content="chosenSnapshotTiers[selectedTierNodeRole][index].name"
                                        :disabled="chosenSnapshotTiers[selectedTierNodeRole][index].readOnly"
                                        @change="onTierSelect($event,tier,index,'snapshot')">
                                 <option v-for="n in showAvailableTiers(index,'snapshot')" :value="n"
                                         :selected="n.id === chosenSnapshotTiers[selectedTierNodeRole][index].id">{{
                                         n.name
                                     }}</option>
                              </select>
                           </td>
                           <td>
                              <select v-model="chosenSnapshotTiers[selectedTierNodeRole][index].storage"
                                      :disabled="chosenSnapshotTiers[selectedTierNodeRole][index].readOnly"
                                      v-if="showTierStorage(index,'snapshot')" class="tierName">
                                  <option :value="undefined" disabled hidden selected>Select storage</option>
                                  <option v-for="[storage, path] in showAvailableStorages(index,'snapshot')"
                                          :value="storage">{{ storage }}</option>
                              </select>
                           </td>
                           <td>
                              <input v-model="chosenSnapshotTiers[selectedTierNodeRole][index].retentionAmount"
                                     v-if="showAfterSelect(index)" class="tierName" data-lpignore="true"
                                     placeholder="after">
                           </td>
                           <td>
                              <select v-model="chosenSnapshotTiers[selectedTierNodeRole][index].retentionType"
                                      v-if="showAfterSelect(index)" class="tierName">
                                 <option :value="undefined" disabled hidden selected>Select retention strategy</option>
                                 <option value="minutes">MINUTES (time based)</option>
                                 <option value="hours">HOURS (time based)</option>
                                 <option value="days">DAYS (time based)</option>
                                 <option value="MB">MEGABYTES (size based)</option>
                                 <option value="GB">GIGABYTES (size based)</option>
                              </select>
                           </td>
                           <td style="width: 15px"><span v-if="showAddTier(index,'snapshot')" class="add-tier"
                                                         style="display: none; width: 15px; float: right !important;"
                                                         title="Add Tier" @click="addSnapshotTier()"><i
                                   class="fas fa-plus"></i></span></td>
                        </tr>
                     </table>
                  </span>
               </li>
               <li>
                  <span class="narrow">&nbsp;</span>
                  <span>
                  <button class="button" @click.prevent="checkAndUpdateContext()">Save</button>
                  <button class="button" @click.prevent="cancelUpdate()">Cancel</button>
                  </span>
               </li>
            </ul>
         </form>
      </div>
   </section>
   <modal height="270" name="delete-context" width="600">
      <div class="column configuration modal">
         <h2>Delete context {{ deleteContextData.context }}</h2>
         <p>
            This will delete all data for this context. Please re-type the name of the context to delete to continue.
         </p>
         <form>
            <ul>
               <li>
                  <span>Context Name</span>
                  <span><input v-model="deleteContextData.retypeContext"/></span>
               </li>
               <li>
                  <span>Preserve Event Store</span>
                  <span><input v-model="deleteContextData.preserveData" type="checkbox"/></span>
               </li>
               <li>
                  <span>&nbsp;</span>
                  <span>
                  <button class="button" @click.prevent="doDeleteContext()">Delete</button>
                  <button class="button" @click.prevent="hideModal('delete-context')">Cancel</button>
                  </span>
               </li>
            </ul>
         </form>
      </div>
   </modal>

       <modal height="500" name="about-multitier" width="800">
      <div class="column configuration modal">
<h2>Important Information on Multi-tiered Storage Configuration</h2>
<p>Multi-tiered storage is a useful tool that allows you to store data across different levels of storage media based on access speed and cost. This helps optimize performance and reduce overall storage costs by placing frequently accessed data on faster storage media, such as SSDs, and less frequently accessed data on slower but more cost-effective storage media, such as HDDs.</p>
          <p><b>Please note that once you have added a storage tier, it cannot be removed. </b> Therefore, it is important to carefully consider your storage requirements and configure the tiers appropriately. <b>
              A misconfigured storage tier can result in performance degradation and decreased efficiency, so be sure to select the appropriate retention strategy for each tier to ensure optimal performance and data accessibility.</b></p>
<p>For example, you can move events to a slower storage tier once they have been snapshotted and the snapshot is available on the faster tier.</p>
      <button class="button" @click.prevent="hideModal('about-multitier')">I understand</button>
      </div>
   </modal>

    <modal name="black_hole" width="600" height="320">
            <div class="column configuration modal">
                <h2>Ephemeral context</h2>
                <p>
                    Selecting black hole as tier will mark your context as ephemeral which means data is permanently removed after a specified retention interval.
                    Once data is removed, it cannot be recovered.
                </p>
                <p>
                    Use this feature with caution and only if you are certain that you no longer need the data.
                </p>
                <form>
                    <ul>
                        <li>
                            <span>&nbsp;</span>
                            <span>
                                <button @click.prevent="hideModal('black_hole')" class="button">I understand</button>
                            </span>
                        </li>
                    </ul>
                </form>

            </div>
    </modal>

     <modal name="create-mt-context" width="600" height="330">
      <div class="column configuration modal">
         <h2>Creating multi-tier storage</h2>
         <p>
            <b>Please note that once you have added a storage tier, it cannot be removed. </b> Therefore, it is important to carefully consider your storage requirements and configure the tiers appropriately. <b>
              A misconfigured storage tier can result in performance degradation and decreased efficiency, so be sure to select the appropriate retention strategy for each tier to ensure optimal performance and data accessibility.</b>
         </p>
         <form>
            <ul>
               <li>
                  <span>&nbsp;</span>
                  <span>
                  <button class="button" @click.prevent="createContext()">Create context</button>
                  <button class="button" @click.prevent="hideModal('create-mt-context')">Cancel</button>
                  </span>
               </li>
            </ul>
         </form>
      </div>
   </modal>

     <modal name="update-mt-context" width="600" height="330">
      <div class="column configuration modal">
         <h2>Multi-tier storage</h2>
         <p>
            <b>Please note that once you have added a storage tier, it cannot be removed. </b> Therefore, it is important to carefully consider your storage requirements and configure the tiers appropriately. <b>
              A misconfigured storage tier can result in performance degradation and decreased efficiency, so be sure to select the appropriate retention strategy for each tier to ensure optimal performance and data accessibility.</b>
         </p>
         <form>
            <ul>
               <li>
                  <span>&nbsp;</span>
                  <span>
                  <button class="button" @click.prevent="doUpdateContext()">Update context</button>
                  <button class="button" @click.prevent="hideModal('update-mt-context')">Cancel</button>
                  </span>
               </li>
            </ul>
         </form>
      </div>
   </modal>

        <modal name="multitier-add-storage" width="800" height="550">
            <div class="column configuration modal">
                <h2>Custom storage tier</h2>
                <p>
                    The Custom storage tier enables you to set a custom location for a specific tier in Axon Server. <br/> You can choose storage via a dropdown menu.
                </p>
                <p>
                      To add storage locations to the dropdown menu, you need to configure Axon Server with additional properties. This can be done either through a property file or environment variables, using the following syntax:
                </p>
                <p>
                    <code>axoniq.axonserver.event.storages.{storage name}={path to storage}</code>
                    <code>axoniq.axonserver.snapshot.storages.{storage name}={path to storage}</code>
                </p>
                <p> For example, to set the slow_disk storage location to <code>/hhd2/eventstore</code>, you can add the following line to your configuration:</p>
                <p>
                    <code>axoniq.axonserver.event.storages.slow_disk=/hhd2/eventstore</code>
                    <code>axoniq.axonserver.snapshot.storages.slow_disk=/hhd2/eventstore</code>
                </p>
                <p>
                    <strong>Its' important to configure the given storage on all nodes in the Axon Server cluster.</strong>
                </p>
                <form>
                    <ul>
                        <li>
                            <span>&nbsp;</span>
                            <span>
                                <button @click.prevent="hideModal('multitier-add-storage')" class="button">Ok</button>
                            </span>
                        </li>
                    </ul>
                </form>

            </div>
    </modal>

</span>